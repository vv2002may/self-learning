/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.crio.xlido;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static com.github.stefanbirkner.systemlambda.SystemLambda.*;

@DisplayName("App Test")
public class AppTest{


    private final PrintStream standardOut = System.out;
    private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();


    @BeforeEach
    public void setUp() {
        System.setOut(new PrintStream(outputStreamCaptor));
    }

    @Test
    public void CREATE_USER() {
        testFunctionality("CREATE_USER");
    }

    @Test
    public void CREATE_EVENT() {
        testFunctionality("CREATE_EVENT");
    }

    @Test
    public void DELETE_EVENT() {
        testFunctionality("DELETE_EVENT");
    }

    @Test
    public void ADD_QUESTION() {
        testFunctionality("ADD_QUESTION");
    }

    @Test
    public void DELETE_QUESTION() {
        testFunctionality("DELETE_QUESTION");
    }

    @Test
    public void UPVOTE_QUESTION() {
        testFunctionality("UPVOTE_QUESTION");
    }

    @Test
    public void REPLY_QUESTION() {
        testFunctionality("REPLY_QUESTION");
    }

    @Test
    public void LIST_QUESTIONS() {
        testFunctionality("LIST_QUESTIONS");
    }

    @AfterEach
    public void tearDown() {
        System.setOut(standardOut);
    }



    private void testFunctionality(String functionality){
        // Arrange
        Path inputFilePath = getInputFile(functionality);
        Path actualOutputFile = getOutputFile(functionality);
        Path expectedOutputFile = getExpectedOutputFile(functionality);
        
        // Act
        String actualOutput;
		try {
            List<String> file_commands = Files.readAllLines(inputFilePath);
			actualOutput = tapSystemOut(() -> new App().run(file_commands));
            Files.writeString(actualOutputFile, actualOutput, StandardCharsets.UTF_8);
		} catch (Exception e) {
			e.printStackTrace();
		}

        // Assert
        try {
			Assertions.assertTrue(compareByMemoryMappedFiles(expectedOutputFile,actualOutputFile));
		} catch (IOException e) {
			e.printStackTrace();
		}
    }
    
    private Path getInputFile(String folderName) {
        return Paths.get("src","test","resources",folderName,"input.txt");
    }

    private Path getOutputFile(String folderName) {
        return Paths.get("src","test","resources",folderName,"output.txt");
    }

    private Path getExpectedOutputFile(String folderName) {
        return Paths.get("src","test","resources",folderName,"expectedOutput.txt");
    }

    // https://www.baeldung.com/java-compare-files
    private boolean compareByMemoryMappedFiles(Path path1, Path path2) throws IOException {
        try (RandomAccessFile randomAccessFile1 = new RandomAccessFile(path1.toFile(), "r"); 
             RandomAccessFile randomAccessFile2 = new RandomAccessFile(path2.toFile(), "r")) {
            
            FileChannel ch1 = randomAccessFile1.getChannel();
            FileChannel ch2 = randomAccessFile2.getChannel();
            if (ch1.size() != ch2.size()) {
                return false;
            }
            long size = ch1.size();
            MappedByteBuffer m1 = ch1.map(FileChannel.MapMode.READ_ONLY, 0L, size);
            MappedByteBuffer m2 = ch2.map(FileChannel.MapMode.READ_ONLY, 0L, size);
    
            return m1.equals(m2);
        }
    }
}
